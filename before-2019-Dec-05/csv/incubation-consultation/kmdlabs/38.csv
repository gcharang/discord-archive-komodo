AuthorID;Author;Date;Content;Attachments;Reactions;
"455741312273219595";"jl777c#5810";"15-Oct-18 05:15 AM";"THAT is the rule";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:16 AM";"in a realtime system, you cant have any part of the system not keep up. even if it is slower by 1%, eventually it just lags and lags until all falls apart";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:16 AM";"so use the method you got to get very fast continuous blocks for the chat";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:17 AM";"add 8kb opreturns and see what bandwidth can be sustained on a single chain";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:17 AM";"this is the critical number";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 05:17 AM";"I think it will be limited by the node sending it tbh ... but we need to check that";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 05:17 AM";"I got distracted trying to fix oraclesinfo ... but I cant fix it";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:18 AM";"a webcam sampler making transactions might indeed have a difficult time to sustain 256kb/sec";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:18 AM";"but that is 32 8kb transactions per second, so not crazy";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 05:18 AM";"Although we could use something like TxBlaster, as the chat chain has basically unlimited free coins";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:18 AM";"of course, I assumed you would modify txblaster so it added an 8kb opreturn";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 05:19 AM";"ahh yeah, using wallet in daemon its just nt possible at all.";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:19 AM";"bitcoin wallet is pretty slow, yes";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 05:20 AM";"ok well, i guess I stop trying to fix oraclesinfo and hope theo other guy you pinged can work it out. Need to go do some tohter stuff, when I get back tonight I will try and add 8kb opreturn to txbalster.. .we cn jsut se the TROLL chain.. and if we break it or make it too big, can just delete it and start a new one.";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:21 AM";"Where does he 8kb limit come from? Is that the amount of data a single OP_RETURN can store or the amount of data a tx can store in OP_RETURN?";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:21 AM";"basically wondering if we can have multiple OP_RETURN outputs with 8kb each";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:21 AM";"as long as it's below tx limit";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:21 AM";"which is what like 100kb?";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:26 AM";"yea so apparently it's possible to mine txs with multiple OP_RETURN outputs in them, but they will be RejectFromMemoryPool'd by vanilla nodes";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 05:27 AM";"That really doesnt matter, as this chain breaks consensus rules as it is, just change that?";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 05:28 AM";"if using a really massive TX with multiple op_return it will be easier to keep the stream at max badnwidth on the sending side";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:29 AM";"Ah so apparently 100kb is just the max for a ""standard"" tx";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:30 AM";"meaning you can mine txs up to the block size, but again they'd be RejectFromMemoryPool'd by vanilla nodes";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:31 AM";"@jl777c what do you think is best route to take? Many smaller transactions or smaller amount of massive txs?";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:32 AM";"current oracles wouldn't support many OP_RETURNS in one tx";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 05:32 AM";"yes true .... we shoud probably just use it as is ... rather than try and change it ?";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:32 AM";"maybe we just change the limit on a single OP_RETURN?";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:33 AM";"@blackjok3r can you point me to where txblaster builds txs?";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 05:34 AM";"never looked at it ... wil find now and DM";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:34 AM";"ty";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:34 AM";"Also I was thinking that OP_RETURN data can be pruned";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:35 AM";"so maybe we don't need a new chain for each stream";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:38 AM";"just use one opreturn";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:38 AM";"8kb";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:38 AM";"dont need to make any changes";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:38 AM";"other than fast blocks";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:38 AM";"that is why i suggested the method i suggested";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:39 AM";"if you can slam a bunch of 8kb opreturn and get 256kb/sec bandwidth, we can do decentralized streaming";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:39 AM";"getting the right data into the 8kb and reassembling it becomes a dapp level issue";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:40 AM";"the webcam video will have some logical size per opreturn and it might be a bit more or less than 8kb, that is ok. there is some leeway";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:40 AM";"and it doesnt really give you more bandwidth to have 8kb single opreturns or 100kb multiple opreturns";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:40 AM";"what matters is how fast the blocks can confirm (assuming the blocks are full)";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:41 AM";"because if the block is full of data, how much does it matter if it is in 8kb increments or 80kb or 800kb?";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:41 AM";"in fact, you should get slightly higher throughput with the smaller one due to more fitting into a block";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:41 AM";"bandwidth stuff doesnt work exactly like other things";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:41 AM";"the way it's set up now, it will mine a block as soon as there's a single tx in mempool";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:41 AM";"fine";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 05:41 AM";"lesss transactions = more payment though, or does that not apply to op_rteturn?";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:42 AM";"i assume coins costs is not an issue";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 05:42 AM";"coins are free";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 05:42 AM";"well a fauct mine";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:42 AM";"so there is no issue";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 05:42 AM";"as amny faucet mines as you need ... just need to mine them.";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:43 AM";"not sure what faucet has to do with streaming";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:43 AM";"i think just txblast with 8kb opreturn and see what happens";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 05:43 AM";"looking at txblast script now";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 05:47 AM";"just where it makes the tx, add an opreturn to it";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 07:16 AM";"tried to decipher the code for txblaster, but I'm not getting anywhere. I see that withdraw method supports OP_RETURN, but I can't for the life of me figure out how to get that to work with txblast method";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 07:22 AM";"just add ""opreturn"":""hexstr"" at the top of the JSON";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 07:22 AM";"let me check";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 07:22 AM";"curl --url ""http://127.0.0.1:7783"" --data ""{\""userpass\"":\""$userpass\"",\""method\"":\""withdraw\"",\""coin\"":\""CHIPS\"",\""outputs\"":[{\""RHV2As4rox97BuE3LK96vMeNY8VsGRTmBj\"":0.0001}],\""opreturn\"":\""deadbeef\""}""";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 07:23 AM";"so the opreturn string just needs to be 8kb worth of hex";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 07:26 AM";"ok, its a bit more tricky";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 07:26 AM";"I will add it";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 07:30 AM";"ok, in the create txblaster function there are two variables:     int32_t origspendlen; char *passphrase = 0,*opretstr = ""deadbeef"";";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 07:30 AM";"opretstr needs to be hex and it will end up in the opreturn (i think)";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 07:31 AM";"if that was 8kb worth of hex, then the opreturn will be much bigger, but all you should have to change is the deadbeef";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 07:31 AM";"verify it works with deadbeef first, then change it and make sure it adapts";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 07:31 AM";"the passphrase is disabled via set to 0, but if there is a string then that string would be needed to decrypt it on display of the opreturn";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 07:32 AM";"so to make this work for a live stream, there is a webcam -> (seqid + 8kb) packetizers that then is retrieved from a fifo in the create txblaster, but this is more a tonyL thing";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 07:33 AM";"it wont take much time to feed in the right data. the important think is what level of bandwidth we can achieve";"";"";
"439780323497082880";"CMaurice#1685";"15-Oct-18 07:38 AM";"@Alright ./start.sh'd but `{""result"":""coin already there"",""tag"":""11612409106504870123""}
== response_dpow STAKEDB1 ==
{'error': 'cant dPoW same coin again',
 'tag': '5348981008567307586'}`";"";"";
"439780323497082880";"CMaurice#1685";"15-Oct-18 07:38 AM";"back in 45 mins";"";"";
"439780323497082880";"CMaurice#1685";"15-Oct-18 07:38 AM";"^that's for 8 chains";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 07:41 AM";"that's expected";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 07:41 AM";"did it print something about rebuilding blockjok3r branch?";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 07:41 AM";"and stop and restart STAKEDED?";"";"";
"371114647052615681";"Mylo#8306";"15-Oct-18 07:52 AM";"Off topic a little but FYI:  Although a dApp level issue, the smallest chunks I could do with ffmpeg was 160kB from 7MB mp4 vid yesterday.  Have found JavaScript/browser FileAPI which can chunkify stuff for streaming still to test but someon3 commented on being able to split/transmit a 3GB file like this.";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 07:58 AM";"unix has utilities to split files, it isnt hard to do via C either";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 07:58 AM";"just a matter to read 8kb, transmit it, repeat till done";"";"";
"439780323497082880";"CMaurice#1685";"15-Oct-18 08:23 AM";"yep, looks like all good@Alright";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 08:25 AM";"pushed an update to trollbox branch, chatsend will now put unix timestamp as first part of the message then chatreceive can convert it back however the user wants to see it";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 08:26 AM";"default looks like this right now 
`10:22:02-CEST[AlrightðŸ˜„-02ba508228]:echoechoecho`
but if you change arg4 of the chatreceive script it will change the date format to whatever you set";"";"";
"405011811511828481";"Alright#0419";"15-Oct-18 08:27 AM";"going to use it as the basis for sorting chat history ðŸ¤ž";"";"ðŸ’ª (1)";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 08:28 AM";"ok @jl777c  going to have a go at this txblaster with opreturn now.";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 08:29 AM";"jl777 branch";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 08:29 AM";"should be easy for you to put in whatever hardcoded hex into the opreturn";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 08:30 AM";"ok so its just hardcoded into the marketmaker and will send the same opreturn for every vout ?";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 08:30 AM";"creating an external feed will be a matter to have some set of files, maybe numbered, that you load and convert to hexstr";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 08:30 AM";"yes, it is txblaster";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 08:30 AM";"I assume I need to use a whole bunch of vouts to get enough bandwidth to  fill blocks.";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 08:30 AM";"why?";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 08:31 AM";"100 output tx filled block pretty fast and 8kb is a lot of space";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 08:31 AM";"or maybe run more than one txblaster at once ... will try with 1 vout first go and see what happens.";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 08:31 AM";"you want to fill it with opreturns, not vouts";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 08:31 AM";"the bandwidth is measured in number of opreturns";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 08:31 AM";"ðŸ¤”";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 08:31 AM";"any datastream will be encoded into the opreturns";"";"";
"232679450301431808";"blackjok3r#3181";"15-Oct-18 08:31 AM";"so can only have 1 opreturn per vout, and 1 vout per blaster";"";"";
"455741312273219595";"jl777c#5810";"15-Oct-18 08:31 AM";"everything else is overhead";"";"";
