AuthorID;Author;Date;Content;Attachments;Reactions;
"232679450301431808";"blackjok3r#3181";"09-Aug-19 04:32 AM";"yerah... 23 nodes... launching the rest soon...";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 10:18 AM";"RST kicking in for only half a dozen blocks, once in the next 400 blocks, so the 1.5% per 3 blocks seems within range";"";"";
"202999072519356416";"NutellaLicka#4241";"09-Aug-19 12:50 PM";"For any Aussie miners out there. An interesting read in relation to Aussie tax & mining crypto
<https://community.ato.gov.au/t5/Tax/Mining-cryptocurrency/ta-p/4599>";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 01:10 PM";"";"https://cdn.discordapp.com/attachments/456900588018597918/609372843213586468/30x_to_1x.csv";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 01:10 PM";"very interesting and good result!";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 01:10 PM";"after no mining at all for 8 hrs or so, started mining with 1 core. of course exp() had to come to the rescue";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 01:11 PM";"671,1565351503,200f0f0c,0f0f0c00000000000000000000000000,00000000000000000000000000000000,1.0,24
672,1565351517,200f0f0c,0f0f0c00000000000000000000000000,00000000000000000000000000000000,1.0,14
673,1565351526,200f0f0c,0f0f0c00000000000000000000000000,00000000000000000000000000000000,1.0,9
674,1565351537,200f0f0c,0f0f0c00000000000000000000000000,00000000000000000000000000000000,1.0,11
675,1565351549,200f0f0c,0f0f0c00000000000000000000000000,00000000000000000000000000000000,1.0,12
676,1565351553,200f0f0c,0f0f0c00000000000000000000000000,00000000000000000000000000000000,1.0,4
677,1565351555,200f0f0c,0f0f0c00000000000000000000000000,00000000000000000000000000000000,1.0,2";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 01:11 PM";"but the blocks came so fast that RST kicked in, rightly so";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 01:11 PM";"but only for 11 blocks:
678,1565351596,20062c92,062c9200000000000000000000000000,03ac707851eb851eb851eb851eb851eb,2.4,41
679,1565351646,20023a61,023a6100000000000000000000000000,01f8c90b851eb851eb851eb851eb851e,6.8,50
680,1565351737,2004ea95,04ea9500000000000000000000000000,0e6cadff7ced916872b020c49ba5e353,3.1,91
681,1565351806,2006f28d,06f28d00000000000000000000000000,0bb6a2f95810624dd2f1a9fbe76c8b43,2.2,69
682,1565351869,2007bbb9,07bbb900000000000000000000000000,0adf7d74395810624dd2f1a9fbe76c8b,1.9,63
683,1565351886,2002646d,02646d00000000000000000000000000,003e77a978d4fdf3b645a1cac083126e,6.3,17
684,1565351916,2002dd09,02dd0900000000000000000000000000,00e91aed0e5604189374bc6a7ef9db22,5.3,30
685,1565352057,20053bf5,053bf500000000000000000000000000,24dea846a7ef9db22d0e5604189374bc,2.9,141
686,1565352072,20030235,03023500000000000000000000000000,003cd8aac083126e978d4fdf3b645a1c,5.0,15
687,1565352106,20055901,05590100000000000000000000000000,022fec2f5c28f5c28f5c28f5c28f5c28,2.8,34
688,1565352140,20040a0d,040a0d00000000000000000000000000,01a6ed40c49ba5e353f7ced916872b02,3.7,34
689,1565352613,200af505,0af50500000000000000000000000000,648f17dd70a3d70a3d70a3d70a3d70a3,1.4,473";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 01:12 PM";"then somehow the digishield started at too low a diff, probably as most of the 671 to 677 diff of 1 was included in 17 block digishield window";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 01:12 PM";"690,1565352623,200f0f0c,0f0f0c00000000000000000000000000,00000000000000000000000000000000,1.0,10
691,1565352629,200f0f0c,0f0f0c00000000000000000000000000,00000000000000000000000000000000,1.0,6
692,1565352633,200f0f0c,0f0f0c00000000000000000000000000,00000000000000000000000000000000,1.0,4
693,1565352649,2006e174,06e17400000000000000000000000000,00000000000000000000000000000000,2.2,16
694,1565352674,20067784,06778400000000000000000000000000,00000000000000000000000000000000,2.3,25
695,1565352675,2006bfc0,06bfc000000000000000000000000000,00000000000000000000000000000000,2.2,1
696,1565352681,2006d468,06d46800000000000000000000000000,00000000000000000000000000000000,2.2,6";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 01:13 PM";"so of course RST kicked in again, as it should have. lasted for 30 blocks, made up for the extra emission and the transition was perfect!";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 01:13 PM";"727,1565354835,20027678,02767800000000000000000000000000,00000000000000000000000000000000,6.1,24
728,1565354998,20022998,02299800000000000000000000000000,00000000000000000000000000000000,7.0,163
729,1565354999,200226b0,0226b000000000000000000000000000,00000000000000000000000000000000,7.0,1
730,1565355042,20022f88,022f8800000000000000000000000000,00000000000000000000000000000000,6.9,43
731,1565355049,20023b34,023b3400000000000000000000000000,00000000000000000000000000000000,6.7,7
732,1565355067,200235f4,0235f400000000000000000000000000,00000000000000000000000000000000,6.8,18
734,1565355302,20023814,02381400000000000000000000000000,00000000000000000000000000000000,6.8,156
735,1565355309,20022410,02241000000000000000000000000000,00000000000000000000000000000000,7.0,7
736,1565355352,20022524,02252400000000000000000000000000,00000000000000000000000000000000,7.0,43
737,1565355380,200216bc,0216bc00000000000000000000000000,00000000000000000000000000000000,7.2,28
738,1565355434,2002100c,02100c00000000000000000000000000,00000000000000000000000000000000,7.3,54
739,1565355472,20021f48,021f4800000000000000000000000000,00000000000000000000000000000000,7.1,38";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 01:14 PM";"the fist block at 6 diff, probably some edge case, but the rest at the correct diff of 7";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 01:50 PM";"@zawy i see what you mean about the 3 block attack. i just wait for digishield period, mine 3 blocks at 9x, stop. usually RST triggers, but without my 9x hashrate, it ends up back to approx same digishield diff. RST period lasted 6 blocks the first time.

it seems someone can indeed ""steal"" a few blocks each time digishield goes active. not sure how to prevent this as it looks identical to miners getting a bit lucky. total coin emission appears to not be increased though, so at least that part is fixed";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 01:53 PM";"probably some entirely new method like your DAG approach is needed to fully solve this. also this 3 block attack will work on basically any coin, so its not any unique attack vector against RST";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 01:59 PM";"but how much of an attack is this? lets say we can do a full cycle every 30 blocks on average. there would be 30 units of hashing continuously, getting 27 of the blocks. 9x hashing for 20 seconds to get 3 blocks is 3 units of hashing to get 3 blocks... wait, does that mean it is costing everyone the same and there is no economic gain? i guess a slight loss for the always on miners getting 10% less ROI";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 01:59 PM";"but this assumes perfect execution on the part of the 3 block miner. seems like a lot of overhead to get a 10% higher ROI";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 02:00 PM";"and if there are two just 3 block miners, i think the overall hashrate just goes up";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 02:02 PM";"@Alright ```./komodod -ac_name=ZAWY22 -ac_adaptivepow=1 -ac_supply=1000000 -ac_reward=10000000000 -ac_cc=2 -addnode=5.9.102.210 &```";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 02:02 PM";"it is ready for your abuse testing. see if you can get it to do bad things";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 02:03 PM";"also anybody else who can think of a way to get a mining advantage, please test to see. for ASIC miners, i think you will be quite surprised at how it behaves";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 02:40 PM";"The plan I gave at the beginning of yesterday is the best available.  To repeat, or maybe say it a little differently, use  RST to regain lost blocks in I'd say in 3 to 5 blocks without regard to W by doing something like changing the 3 to 4.  Digi and exp() are fine.    This means on-off is possible, but blocks will not be emitted too fast on average.  The only way to make the large miner pay more than constant miners in doing this is to change the difficulty during the block with the EMA, or even make RST active on every block.  The difficulty will then jump up and down a lot every block.  But if a fast solve is submitted, teh large miner has to pay more than average.   Even this plan fails if the miner can turn on and off in T/2 while common miners mine all the time.  The complete solution is to enable every miner to turn on and off with equal speed so that no one can cheat relative to anyone else.  So as the EMA is changing D during the block all miners can switch from one chain to another as the target time makes comes close where it is easier.  Miners liking a coin more will start mining early to increase their chances, but at a larger minnig cost.  People wanting to get it at a low D will not get as many but they will help make target time much tighter around T.     It seems like making it jump around each block is more than many will want, so I would say just RST , digi, and exp() and let the big miners get their 3 blocks.  It may take awhile for that to end up bad.  If the big miners get 3 and leave and RST is made to recover in 3, then constant miners have to pay 2x the average difficulty.";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 02:41 PM";"I will soon have a spreadsheet where you can do testing of the math immediately.  I'll do the C++ code for modellign later.";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 02:42 PM";"I previously didn't know how to do it in spreadsheet, but that target adjustment equation can work backwards to do what's needed.";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 02:54 PM";"When I talk about using the EMA I'm talking about using Digi Shield values as its input but Digi Shield values never being seen in the public. And using rst for the other cases to be more aggressive and exp for the fast drops";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 02:55 PM";"it seems the gain from this is not worth it. i really like how things are working now and the changing diff for each block has the ""attack"" by miners who mine just after tipdiff > 30";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 02:56 PM";"with just a few minable coins using this method all the time they could hop around to the one with the highest ROI. that doesnt seem like a good equation";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 02:56 PM";"as it is now, the RST kicks in only after hashrate boost. inadvertent ones from good miner luck for a few blocks seems to almost always result in a short RST period";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 02:57 PM";"and the digishield offers nice diff stability under constant hashrate";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 02:57 PM";"so if some miners want to hop in for 3 blocks, let them. as soon as there is more than one such miner, it wont work anymore for them";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 03:17 PM";"For W=2 you can use numerator = 15, denominator 100  to have the same 0.5% per block occurence";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 03:18 PM";"cool! i can add a W=2 and reduce the 3 blocks to 2";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 03:18 PM";"that is actually a significant improvement";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 03:18 PM";"W=1 shouldn't be done because th FTL=4 could be used for substantial manipulation";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 03:19 PM";"agreed";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 03:19 PM";"what happens if an attacker tries to backdate timestamps";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 03:19 PM";"say 5 minutes ago to get past the >mediantime requirement";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 03:19 PM";"then can create artificial delays, but i think it will just trigger RST";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 03:21 PM";"15/100 is 9 seconds, so there could be manipulation (he sends his 2nd block at 1 second and      then    leaves to make others see higher difficulty for two blocks and then comes back or he does it the other way if he's   not too large to prevent the W=2 trigger so that he can get a 3rd";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 03:27 PM";"So he cuold be 5x and will sometmies see 7 second blocks so he could make next one +1 and then leaves  So ironically, a miner who is not too big can make the triggers happen to force others to have a higher avg difficulty, so more miners do not want to mine the coin so he's competing with a lower hashrate  AND he's getting it at 1/2 the average difficulty at that hasrate.  Miners leaving regular coins is a non-linear function of difficulty, meaning that a 5x or 10x miner could do this, switching between 4 different coin options to not waste equipment time, and let's say he only drives D up 50% higher....well in some coins that would mean 70% of miners would leave";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 03:28 PM";"I mean avg D would be 50^ higher";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 03:28 PM";"as you say, the solution is to implement a good multicoin miner so everyone can do this";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 03:28 PM";"with competition, this low diff sniping wont work";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 03:28 PM";"right, I'm glad you see that.  A lot of people just completely forget it's a viable option....and it would make solvetimes more exact";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 03:29 PM";"....but....";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 03:31 PM";"the whole reason for a delay between blocks is to make sure the solvetimes are spread out so there are fewer collisions within network delays that would cause orphans.  You can make blocks half as big to make solvetime 2x faster which improves difficulty speed which makes on-off harder.  And at 2x smaller they theoretically propagate 2x faster";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 03:31 PM";"so the collisions are not increased";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 03:34 PM";"So an extreme case of using RST W=2 or EMA to change difficulty during the block can increase collisions, but if it's done mildly, it can decrease collision which are normally bunched at the fast solvetimes due to the poisson.....you could even adjust the DA based on the number of collisions to minimize them.";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 03:35 PM";"My TSA article shows how the histogram is pulled away from being bunched at fast solvetimes......RST is achieving this";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 03:35 PM";"at elast when there is an attack";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 03:35 PM";"it seems to get the fast solves to trigger the W=2, the collisions would be mostly between the snipers, and there shouldnt be that many of them";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 03:36 PM";"if everyone is running the multichain miner and all are hopping to the highest ROI chain, then that chain ends up with a higher hashrate. i think it will all sort itself out";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 03:36 PM";"and collisions are not that big of a deal in the context of dPoW as it will resolve itself pretty quickly";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 03:38 PM";"We are not near collisions being a problem.  I was just pointing out that if  on-off were encouraged to an extreme degree it might look attractive due to solvetim but also has the collisions.";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 03:39 PM";"understood. i will design the multicoin miner to minimize this. with each miner putting in their relative value of coins into the multiminer, the collisions would only be between those with identical coin values";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 03:51 PM";"funnily, the initial test of W=2, didnt trigger, as there was a slow block and it was > 9 seconds, but the W=3 triggered at the same spot. since they all turn on at ht.65. under a normal situation though it looks like it will indeed reduce the number of cheap blocks by 1";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 03:53 PM";"maybe a W=1 with numerator 1, denominator 60, would catch it after one block, but then anybody that does a timestamp 1 more than previous would trigger it. though not sure it is so bad to have RST triggerred spuriously as it just gets block production back to where it should be";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 04:03 PM";"You would have to trigger the rst in the same way you trigger the EMA. You could have the rst running on top of Digi Shield all the time but just a lot less aggressive and how much it changes difficulty based on the solve time. The 0.5% trigger for w equals 1 was less than one second.  A 1 second trigger would need 200 second blocks";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 04:04 PM";"too bad. still 2 easy blocks is a lot better than 3, i think what is in place now is a very very good improvement over status quo";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 04:04 PM";"now we will test it as much as possible to make sure no unexpected behaviors";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 04:38 PM";"2 model mining, make the solve time equal to the square root of the negative natural logarithm a random variable divided by the hash rate divided by the Target* 2 raised to the power of 256";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 04:39 PM";"The natural logarithm is only of the random variable, and the square root covers all of it";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 04:59 PM";"going through your reverse nakamoto articles...";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 04:59 PM";"do you know of any actual VDF in code that already works?";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:00 PM";"it seems a VDF-PoS could make PoS quite effective and it seems it can be done in the current context of blockchain, which is my preference as all the other infrastructure in place would still apply";"";"";
"365714438864633856";"dukeleto#7326";"09-Aug-19 05:01 PM";"@jl777c i could never find any simple ""this is a VDF code"" in C/C++";"";"";
"365714438864633856";"dukeleto#7326";"09-Aug-19 05:01 PM";"anybody who talks about VDFs is usually writing weird academic papers, and if they write code, it's in some weird language or pseudocode";"";"";
"365714438864633856";"dukeleto#7326";"09-Aug-19 05:01 PM";"some kind of VDF in C/C++ might exist somewhere, just haven't found it. It might be called something else, VDF is not a universal term";"";"";
"365714438864633856";"dukeleto#7326";"09-Aug-19 05:02 PM";"When zawy first started talking about them, I tried to research, but the data was extremely scarce";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 05:10 PM";"Chia is pushnig the VDF tech";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:11 PM";"i can see how to do half a VDF, where it takes 64x longer to create and can be verified in parallel. but for a single entity to validate it would require the same amount of time";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:12 PM";"maybe a penalty if any subpart of the data is disproven, or blocks would just take time to verify";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 05:12 PM";"Bram Cohen (bit torrent creator) brought awareness of them to the blockchain world.  He blocked me on twitter for pestering them about their difficulty problems";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 05:17 PM";"Through some deep math magic that might take me a long to time to intuitively feel how it works, the VDF outputs a random value that works like a hash.  You can efficiently check they went through the process by comparing the output to the inputs without having to do the work.";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:19 PM";"the effciently checking part seems quite amazing, seems they use some zksnark tech";"";"";
"365714438864633856";"dukeleto#7326";"09-Aug-19 05:30 PM";"@zawy hat tip for getting blocked, you must have asked some good questions ðŸ˜…";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:32 PM";"https://github.com/Chia-Network/vdf-competition/blob/master/vdf.cpp";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:32 PM";"seems just a bunch of GMP calls";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:33 PM";"but i dont see the verifier";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 05:34 PM";"To be fair he said for me and another guy to take him out of our thread. I replied that he needed to be reading that thread, then he blocked me";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:35 PM";"what about using a CPU orient algo, like curve25519 in a chain. calculate 64 million, posting the partial result for every million.";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:36 PM";"now anybody can verify in 1/64th time any two adjacent values";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:37 PM";"given the same amount of time, you can fully validate the entire chain, but that could end up being a lot of work";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:37 PM";"but it can be done statistically but treating it like mining hashes";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:38 PM";"so in addition to the 64 values, the one that has the lowest bnTarget equivalent is also posted, along with its position.";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:38 PM";"then on average in half a million curve25519 you can verify it goes to the next of the 64 entries";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:39 PM";"so kind of like mining, but with a fixed amount to calculate. can start from the hash(prevvdf & pubkey)";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:41 PM";"you can cmult the 64 values and end up with the last one as these are all basically multiplicative products";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 05:44 PM";"the fact that the product of 2 million elements is the same as the product of 2, this is close to being verifiable quickly, but for an ultimately serial calc, i dont see how to allow a fast validation. parallel validation on something that is only serially calculable is not quite a vdf";"";"";
"352488299077566475";"zawy#5864";"09-Aug-19 05:57 PM";"the links on this page are good if you didn't see it.  MIT has a digital currency lab that's interested in it, so that's where some of the videos come from https://vdfresearch.org/";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 06:41 PM";"that math seems too deep for me, but i have a possible solution!
let me know if you see any fundamental problems.

1. the idea is to use a curve25519 chain, which is basically multiplying field elements, over and over, in a chain. in order to calculate the ending value of the chain, the entire chain needs to be computed. 

the problem is that to verify the chain, it seems that you need to also verify the entire chain, however, let us have a global reference chain that is very long, but known to all. what this means is that the final product can be known to all. Of course, if the full chain is known, then it seems there cant be much use, but the trick is the ""monkeys typing shakespeare"" idea. given a long enough chain, eventually there will be all possible data (in the parts of the encoded field element with full dynamic range.

so let us specify an offset into the field element and use two full dynamic range bytes as the ones that have to have the next part of the message.

the message needs to change each block to prevent any lookup tables being created, so there is a per block blinding hash that is not known until the block starts, let us say it is the value of the previous blockchash, with height, pubkey and some other (tbd) things added to the hash. 

now we need to search for this hash 2 bytes at a time in the curve25519 chain. on average it will take about 65536 iterations to find the exact 16bit pattern in the specified two bytes. which is an average of a million iterations per 256 bits hash. 

here comes the rapid validation part!";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 06:41 PM";"as each of the 16 elements are found, they are the product of all the elements before it.  multiplying them together gets the same result as a single chain that ends at the last one, so there just needs to be a final field product that goes from the 16 special field elements to the very end of the globally known chain. 17 cmults can validate that the 16 special field elements were in the chain.

one problem is that a parallel search can search in parallel for sequences and since it is multiplication, the order doesnt matter. to avoid this attack, each of the 16 elements needs to be anchored to a specific 1/64th of the global one, and in order. this doubles the required number of elements, but the time for 32 mults is very fast. there can probably be statistical tests to detect parallel searching within a segment, since we have a globally known chain, the resolution can be made every 10,000 elements";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 06:44 PM";"my guess is you can define the math to get a very high probability of a non-parallel search";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 06:47 PM";"and if the search is known to have been serial, we know that it took a long time to calculate as curve25519 is already CPU optimized and i dont know of any way to parallelize a curve25519 chain. I already have code that searches for one byte values in curve25519, but it was random values, not a chain, still this wouldnt be hard at all and if it implements a VDF, it seems worth doing";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 07:00 PM";"an improvement to this to prevent any chance of pre-computing lookup tables is that at each link of the chain, you hash the field element to look for the 16bits. since it is hashed with a height specific data not known until that height started, you cant precompute the hashes derived from that";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 07:00 PM";"now all 32 bytes have full dynamic range as it is the output of SHA256";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 07:00 PM";"validation now needs 16 extra SHA256, which is also very fast";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 07:04 PM";"but i wonder if this breaks the serialization aspect... it does seem like some cheating is possible by scanning a small enough range in parallel, so need to tweak it a bit more.";"";"";
"455741312273219595";"jl777c#5810";"09-Aug-19 07:08 PM";"also if the full curve25519 chain is too small, large computers can load it all in memory. so it needs to be much bigger than can be stored. which gives the idea that the starting point for any given block is changing and then to search, the chain needs to be recreated from the new starting point";"";"";
